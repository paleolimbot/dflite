<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Dflite by paleolimbot</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Dflite</h1>
        <p>Lightweight DataFrame for data science.</p>

        <p class="view"><a href="https://github.com/paleolimbot/dflite">View the Project on GitHub <small>paleolimbot/dflite</small></a></p>


        <ul>
          <li><a href="https://github.com/paleolimbot/dflite/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/paleolimbot/dflite/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/paleolimbot/dflite">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="dflite-the-quick--easy-dataframe" class="anchor" href="#dflite-the-quick--easy-dataframe" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DFLite: The Quick &amp; Easy DataFrame</h1>

<p>The data frame was a concept I first came across in R, where it is a fundemental component of data analysis. Never having done much data analysis in Python, I came across a situation where I needed a data frame but didn't know about the <code>pandas</code> implementation, so I went about writing my own <code>DataFrame</code> class. When I realized the <code>pandas</code> version existed, I immediately switched all my code over only to find that for my application, <strong>the pandas DataFrame was over 2 times slower</strong> than my lightweight <code>DataFrame</code>. So I spent some time making sure the interfaces were the same (at least in what I was doing) and made some nice 'this is what you would expect' modifications for personal use in the future.</p>

<p>In general, the <code>pandas</code> data frame performs quite well, especially with large datasets. I'm sure that this class has quite a few holes in it, but the idea of a lightweight <code>DataFrame</code> for Python is worth pursuing in the future. You can find the <a href="https://github.com/paleolimbot/dflite">source code for <code>dflite</code></a> on GitHub, including a copy of this notebook. Here's some general usage.</p>

<h2>
<a id="importing" class="anchor" href="#importing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Importing</h2>

<p>Importing is easy, the only dependency is <code>numpy</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> dflite <span class="pl-k">as</span> df</pre></div>

<h2>
<a id="creating-a-dataframe" class="anchor" href="#creating-a-dataframe" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating a DataFrame</h2>

<p>Usually all I want to do is create a <code>DataFrame</code> from a CSV file, but in code there's a couple of other ways to construct the class. The <code>DataFrame.from_records()</code> method is probably the most useful, creating a <code>DataFrame</code> from an iterable grouped by record (items coming out of a Postgres database via <code>psycopg2</code> are a good example). This is more or less equivalent to the <code>pandas</code> method of the same name. For now, we'll demo the class with the small CSV included in the directory.</p>

<div class="highlight highlight-source-python"><pre>data <span class="pl-k">=</span> df.read_csv(<span class="pl-s"><span class="pl-pds">"</span>test.csv<span class="pl-pds">"</span></span>)
data.head()</pre></div>

<table>
<tr>
<td></td>
<td><strong>Time (UTC)</strong></td>
<td><strong>Latitude</strong></td>
<td><strong>Longitude</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:18</td>
<td>45.10303743</td>
<td>-64.29103034</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
<td>-64.29080328</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>2016-03-02 17:50:23</td>
<td>45.10251977</td>
<td>-64.29080362</td>
</tr>
</table>

<p>The <code>read_csv()</code> function is pretty much the same as the <code>pandas</code> version, at least for simple usage. You can also pass in a file-like object and a <code>driver=</code> parameter. Currently only <code>csv</code> files are supported, but they're the most common, so hey.</p>

<p>The <code>tail()</code> method works much the same as the <code>head()</code> method.</p>

<div class="highlight highlight-source-python"><pre>data.tail(<span class="pl-c1">3</span>)</pre></div>

<table>
<tr>
<td></td>
<td><strong>Time (UTC)</strong></td>
<td><strong>Latitude</strong></td>
<td><strong>Longitude</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:54</td>
<td>45.09937809</td>
<td>-64.29696471</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:55</td>
<td>45.09924766</td>
<td>-64.2972626</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:56</td>
<td>45.09911724</td>
<td>-64.29754859</td>
</tr>
</table>

<p>Notice here how the indicies are 0, 1, and 2, where they <em>should</em> be the last few indicies of the <code>DataFrame</code>. The <code>pandas.DataFrame</code> supports (I would argue is slightly obsessed with) thd idea of <strong>index</strong>es for rows/columns. For rows I almost never have a reason to access them by anything other than an integer (certainly not a string), and because of this I don't bother with them. Since <code>tail()</code> is basically just checking the <code>DataFrame</code>, I didn't bother to re-number the rows (<code>tail()</code> is actually just shorthand for <code>data.iloc[(len(data)-nrows):len(data)])</code>, so it's really its own <code>DataFrame</code> object).</p>

<h2>
<a id="columns" class="anchor" href="#columns" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Columns</h2>

<p>Column names can be accessed and set just like the <code>pandas</code> version:</p>

<div class="highlight highlight-source-python"><pre>data.columns</pre></div>

<pre><code>['Time (UTC)', 'Latitude', 'Longitude']
</code></pre>

<div class="highlight highlight-source-python"><pre>data.columns <span class="pl-k">=</span> (<span class="pl-s"><span class="pl-pds">"</span>col1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>col2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>col3<span class="pl-pds">"</span></span>)
data.head()</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:18</td>
<td>45.10303743</td>
<td>-64.29103034</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
<td>-64.29080328</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>2016-03-02 17:50:23</td>
<td>45.10251977</td>
<td>-64.29080362</td>
</tr>
</table>

<p>Column values can be added and removed in a similar way</p>

<div class="highlight highlight-source-python"><pre>data[<span class="pl-s"><span class="pl-pds">"</span>col1<span class="pl-pds">"</span></span>]</pre></div>

<pre><code>array(['2016-03-02 17:50:18', '2016-03-02 17:50:19', '2016-03-02 17:50:20',
       '2016-03-02 17:50:21', '2016-03-02 17:50:22', '2016-03-02 17:50:23',
       '2016-03-02 17:50:24', '2016-03-02 17:50:25', '2016-03-02 17:50:26',
       '2016-03-02 17:50:27', '2016-03-02 17:50:28', '2016-03-02 17:50:29',
       '2016-03-02 17:50:30', '2016-03-02 17:50:31', '2016-03-02 17:50:32',
       '2016-03-02 17:50:33', '2016-03-02 17:50:34', '2016-03-02 17:50:35',
       '2016-03-02 17:50:36', '2016-03-02 17:50:37', '2016-03-02 17:50:38',
       '2016-03-02 17:50:39', '2016-03-02 17:50:40', '2016-03-02 17:50:41',
       '2016-03-02 17:50:42', '2016-03-02 17:50:43', '2016-03-02 17:50:44',
       '2016-03-02 17:50:45', '2016-03-02 17:50:46', '2016-03-02 17:50:47',
       '2016-03-02 17:50:48', '2016-03-02 17:50:49', '2016-03-02 17:50:50',
       '2016-03-02 17:50:51', '2016-03-02 17:50:52', '2016-03-02 17:50:53',
       '2016-03-02 17:50:54', '2016-03-02 17:50:55', '2016-03-02 17:50:56'], 
      dtype='&lt;U19')
</code></pre>

<p>Columns can also be accessed by index (this isn't possible in the <code>pandas</code> version, and I'm not quite sure why)</p>

<div class="highlight highlight-source-python"><pre>data[<span class="pl-c1">0</span>]</pre></div>

<pre><code>array(['2016-03-02 17:50:18', '2016-03-02 17:50:19', '2016-03-02 17:50:20',
       '2016-03-02 17:50:21', '2016-03-02 17:50:22', '2016-03-02 17:50:23',
       '2016-03-02 17:50:24', '2016-03-02 17:50:25', '2016-03-02 17:50:26',
       '2016-03-02 17:50:27', '2016-03-02 17:50:28', '2016-03-02 17:50:29',
       '2016-03-02 17:50:30', '2016-03-02 17:50:31', '2016-03-02 17:50:32',
       '2016-03-02 17:50:33', '2016-03-02 17:50:34', '2016-03-02 17:50:35',
       '2016-03-02 17:50:36', '2016-03-02 17:50:37', '2016-03-02 17:50:38',
       '2016-03-02 17:50:39', '2016-03-02 17:50:40', '2016-03-02 17:50:41',
       '2016-03-02 17:50:42', '2016-03-02 17:50:43', '2016-03-02 17:50:44',
       '2016-03-02 17:50:45', '2016-03-02 17:50:46', '2016-03-02 17:50:47',
       '2016-03-02 17:50:48', '2016-03-02 17:50:49', '2016-03-02 17:50:50',
       '2016-03-02 17:50:51', '2016-03-02 17:50:52', '2016-03-02 17:50:53',
       '2016-03-02 17:50:54', '2016-03-02 17:50:55', '2016-03-02 17:50:56'], 
      dtype='&lt;U19')
</code></pre>

<div class="highlight highlight-source-python"><pre>data[<span class="pl-s"><span class="pl-pds">"</span>newcol<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">10</span>
data.head()</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
<td><strong>newcol</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:18</td>
<td>45.10303743</td>
<td>-64.29103034</td>
<td>10</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
<td>10</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
<td>10</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
<td>10</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
<td>-64.29080328</td>
<td>10</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>2016-03-02 17:50:23</td>
<td>45.10251977</td>
<td>-64.29080362</td>
<td>10</td>
</tr>
</table>

<div class="highlight highlight-source-python"><pre>data[<span class="pl-s"><span class="pl-pds">"</span>newcol<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> data[<span class="pl-s"><span class="pl-pds">"</span>newcol<span class="pl-pds">"</span></span>] <span class="pl-k">+</span> <span class="pl-c1">4</span>
data.head()</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
<td><strong>newcol</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:18</td>
<td>45.10303743</td>
<td>-64.29103034</td>
<td>14</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
<td>14</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
<td>14</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
<td>14</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
<td>-64.29080328</td>
<td>14</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>2016-03-02 17:50:23</td>
<td>45.10251977</td>
<td>-64.29080362</td>
<td>14</td>
</tr>
</table>

<div class="highlight highlight-source-python"><pre><span class="pl-k">del</span> data[<span class="pl-s"><span class="pl-pds">"</span>newcol<span class="pl-pds">"</span></span>]
data.head()</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:18</td>
<td>45.10303743</td>
<td>-64.29103034</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
<td>-64.29080328</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>2016-03-02 17:50:23</td>
<td>45.10251977</td>
<td>-64.29080362</td>
</tr>
</table>

<h2>
<a id="rows" class="anchor" href="#rows" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rows</h2>

<p>In <code>pandas</code>, rows are accessed through the <code>iloc</code> attribute, so after considerable changing of code, so does mine. Here, <code>data.iloc[3]</code> will give the fourth row (as a <code>dict</code> ish object), and <code>data.iloc[3, :]</code> will give a <code>DataFrame</code> with only one row. The <code>pandas</code> version also has a <code>loc[]</code> option where names can be specified, but in this implementation <code>iloc</code> and <code>loc</code> are identical, and so you can pass more or less anything between the brackets and get a sensible result. </p>

<div class="highlight highlight-source-python"><pre>row <span class="pl-k">=</span> data.iloc[<span class="pl-c1">3</span>]
row</pre></div>

<table>
<tr>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
</tr>
<tr>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
</tr>
</table>

<p>Of course, I've made the nice <code>_repr_html_()</code> method so it displas nicely but each row is actually a <code>_DFRow</code> object, which is a subclass of <code>dict</code> that keeps its values in order. This means you can index it by column name or by index.</p>

<div class="highlight highlight-source-python"><pre>row[<span class="pl-s"><span class="pl-pds">"</span>col1<span class="pl-pds">"</span></span>]</pre></div>

<pre><code>'2016-03-02 17:50:21'
</code></pre>

<div class="highlight highlight-source-python"><pre>row[<span class="pl-c1">0</span>]</pre></div>

<pre><code>'2016-03-02 17:50:21'
</code></pre>

<p>Iterating through rows is done using the <code>itertuples()</code> method, which returns an iterator that iterates through the rows in the same way as the <code>pandas</code> version. Because <code>pandas</code> returns its row with the <code>0</code>th item as the row number (or row <em>index</em>, if you believe in that kind of thing), this method does as well.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">for</span> row <span class="pl-k">in</span> data.head().itertuples():
    <span class="pl-c1">print</span>(row[<span class="pl-c1">0</span>], row[<span class="pl-s"><span class="pl-pds">"</span>col2<span class="pl-pds">"</span></span>], row[<span class="pl-c1">1</span>])</pre></div>

<pre><code>0 45.10303743 2016-03-02 17:50:18
1 45.10291441 2016-03-02 17:50:19
2 45.10279595 2016-03-02 17:50:20
3 45.1026838 2016-03-02 17:50:21
4 45.10259138 2016-03-02 17:50:22
5 45.10251977 2016-03-02 17:50:23
</code></pre>

<h2>
<a id="subsetting" class="anchor" href="#subsetting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Subsetting</h2>

<p>Each column is a NumPy <code>ndarray</code> object, so it can be indexed like any other <code>ndarray</code> object (i.e. by a <code>list</code> of desired rows, by an <code>ndarray</code> of logicals, by a single index, or by a <code>slice</code>). Some of this notation is available in the <code>iloc</code> method as well, which returns a single value (if two <code>int</code>s are passed), a <code>_DFRow</code> (if only a single integer is passed), or a subsetted <code>DataFrame</code> (if some combination of slices/ints/lists is passed). See the following examples:</p>

<div class="highlight highlight-source-python"><pre>data.iloc[<span class="pl-c1">1</span>:<span class="pl-c1">3</span>]</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
</tr>
</table>

<div class="highlight highlight-source-python"><pre>data.iloc[<span class="pl-c1">1</span>:<span class="pl-c1">5</span>, <span class="pl-c1">0</span>:<span class="pl-c1">2</span>]</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
</tr>
</table>

<div class="highlight highlight-source-python"><pre>data.iloc[[<span class="pl-c1">2</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">33</span>], (<span class="pl-s"><span class="pl-pds">"</span>col1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>col3<span class="pl-pds">"</span></span>)]</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col3</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:20</td>
<td>-64.29089237</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:23</td>
<td>-64.29080362</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:23</td>
<td>-64.29080362</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:51</td>
<td>-64.29613321</td>
</tr>
</table>

<p>Notice again how our original row number aren't preserved. You can work around this by making a column with your original row numbers. I get how this could be annoying, but including it was too complicated and wasn't necessary for what I was doing.</p>

<div class="highlight highlight-source-python"><pre>data[<span class="pl-s"><span class="pl-pds">"</span>original_rows<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-c1">list</span>(<span class="pl-c1">range</span>(<span class="pl-c1">len</span>(data)))
data.iloc[[<span class="pl-c1">2</span>, <span class="pl-c1">5</span>, <span class="pl-c1">5</span>, <span class="pl-c1">33</span>], (<span class="pl-s"><span class="pl-pds">"</span>original_rows<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>col1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>col3<span class="pl-pds">"</span></span>)]</pre></div>

<table>
<tr>
<td></td>
<td><strong>original_rows</strong></td>
<td><strong>col1</strong></td>
<td><strong>col3</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2</td>
<td>2016-03-02 17:50:20</td>
<td>-64.29089237</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>5</td>
<td>2016-03-02 17:50:23</td>
<td>-64.29080362</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>5</td>
<td>2016-03-02 17:50:23</td>
<td>-64.29080362</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>33</td>
<td>2016-03-02 17:50:51</td>
<td>-64.29613321</td>
</tr>
</table>

<p>All of the nice indexing things we can do with NumPy are also available in the 'rows' part of the index:</p>

<div class="highlight highlight-source-python"><pre>data.iloc[data[<span class="pl-s"><span class="pl-pds">"</span>col2<span class="pl-pds">"</span></span>] <span class="pl-k">&gt;</span> <span class="pl-c1">45.1022</span>]</pre></div>

<table>
<tr>
<td></td>
<td><strong>col1</strong></td>
<td><strong>col2</strong></td>
<td><strong>col3</strong></td>
<td><strong>original_rows</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2016-03-02 17:50:18</td>
<td>45.10303743</td>
<td>-64.29103034</td>
<td>0</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-03-02 17:50:19</td>
<td>45.10291441</td>
<td>-64.29095464</td>
<td>1</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-03-02 17:50:20</td>
<td>45.10279595</td>
<td>-64.29089237</td>
<td>2</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2016-03-02 17:50:21</td>
<td>45.1026838</td>
<td>-64.29084603</td>
<td>3</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2016-03-02 17:50:22</td>
<td>45.10259138</td>
<td>-64.29080328</td>
<td>4</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>2016-03-02 17:50:23</td>
<td>45.10251977</td>
<td>-64.29080362</td>
<td>5</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>2016-03-02 17:50:24</td>
<td>45.10245523</td>
<td>-64.29083152</td>
<td>6</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>2016-03-02 17:50:25</td>
<td>45.10240112</td>
<td>-64.29086638</td>
<td>7</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>2016-03-02 17:50:26</td>
<td>45.10233343</td>
<td>-64.2909347</td>
<td>8</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>2016-03-02 17:50:27</td>
<td>45.10227411</td>
<td>-64.29102036</td>
<td>9</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>2016-03-02 17:50:28</td>
<td>45.1022154</td>
<td>-64.29111654</td>
<td>10</td>
</tr>
</table>

<h2>
<a id="exporting" class="anchor" href="#exporting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Exporting</h2>

<p>Writing the <code>DataFrame</code> to a CSV is probably the easiest way to export, although TSV is also supported. The <code>to_csv()</code> method works more or less like the <code>pandas</code> version, and can take a file-like object as well as a filename.</p>

<h2>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Performance</h2>

<p>As I mentioned earlier, running the <code>pandas.DataFrame</code> in production code that used quite a lot of <code>DataFrame</code>s was quite slow. I have a feeling that there's a lot of overhead involved with the convenience of multiple indexing and built-in plotting support that slows the class down when there isn't a need for it. There's also probably a lot of work to be done on this class that can add convenience without comprimising performance, but I'll leave that up to some folks with a bit more spare time than I do. Cheers!</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/paleolimbot">paleolimbot</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-73397650-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
